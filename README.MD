## CSNaturalMouseMotion ##

Библиотека позволяет смоделировать движения курсора мыши максимально реалистично похожим на движение мыши человеком, курсор двигаясь по траектории случайным образом изгибается, меняет ускорение, появляются промахи, шумы итд.  
Создавалась для использования совместно с zennoposter так как встроенные в api методы легко детектировались бот детекторами.

В место курсора на экране, можно направить вывод в любую другую библиотеку или устройство, для этого есть соответстаующие интерфейсы..

Некоторые функции CSNaturalMouseMotion содержат:

  * **Deviation**: Отклонение уводит мышь от прямой траектории, создавая дугу вместо прямой линии.
  * **Noise**: Шум создает ошибки в движении, это может имитировать дрожание рук, если кто-то использует неточную мышь или плохую поверхность под мышью.
  * **Speed** и **flow**: скорость и ускорение определяют продвижение мыши в данный момент времени, например, возможно, что движение начинается медленно, а затем набирает скорость или просто изменяется.
  * **Overshoots**: Промахи происходит, если пользователь не на 100% точен с помощью мыши и вместо этого попадает в область рядом с целью.
  * **Coordinate translation**: Трансляция координат позволяет указать смещение и размеры, чтобы ограничить перемещение в области, отличной от экрана, или на виртуальном экране внутри реального экрана.

### Запуск: ###

Создаете фабрику: `MouseMotionFactory factory = new MouseMotionFactory();`  
Чтобы создать экземпляр `MouseMotion`, вы используете экземпляр фабрики:  
`MouseMotion motion = MouseMotionFactory.Build(int xDest, int yDest);`

`MouseMotion` можно запускать с помощью `motion.Move();`  
который затем перемещает курсор. 
Этот экземпляр можно сохранить для вызова позже или повторно.

Сокращенный метод перемещения мыши также можно найти в фабрике, вызвав  
`MouseMotionFactory.instance.Move(int xDest, int yDest);`

### Готовые шаблоны ###

CSNaturalMouseMotion включает [FactoryTemplates](https://github.com/alekseyaz/CSNaturalMouseMotion/blob/master/CSNaturalMouseMotion/Util/FactoryTemplates.cs) класс, который содержит множество вариантов поведения для ваших симуляций.

  * **GrannyMotionFactory** - медленное и неуклюжее движение мыши с большим количеством шума..
  * **FastGamerMotionFactory** - это быстрое и постоянное движение с низким уровнем шума, имитирующее поведение человека похожее на профессионального геймера.
  * **AverageComputerUserMotionFactory** - это движение средней скорости со средними настройками, медленнее, чем у быстрого игрока, но намного быстрее, чем у бабушки.
  * **DemoRobotMotionFactory** - это безликий робот с постоянной скоростью без ошибок.
  
### Перевод координат с реального экрана на виртуальный ###

Иногда вам может потребоваться имитировать движение мыши где-нибудь еще, а не на реальном экране, или удерживать мышь в меньшей области экрана.
В этом случае можно выполнить преобразование координат, ограничив экран только определенной областью. Следующий код ограничивает
перемещение в поле **500*500** с координатами **(50,50)** на экране.

```csharp
MouseMotionFactory factory = new MouseMotionFactory();
Size screenSize = new Size(500, 500);
Point offset = new Point(50, 50);
factory.Nature = new ScreenAdjustedNature(screenSize, offset);
// Остальные настройки фабрики здесь
```

Например, при вызове `factory.Move(10, 10)` мышь будет перемещена в **(60, 60)** на реальном экране, поскольку смещение равно **(50, 50)**.
Попытка переместить мышь за пределы поля **500x500** с большими значениями приведет к тому, что она ударится о воображаемую стену в реальных координатах экрана **500x500**.

При установке `factory.Nature` все ранее установленные настройки теряются, потому что экземпляр переназначается, что означает, что установка `factory.Nature` должна быть выполнена
в первую очередь, прежде чем будут затронуты другие настройки.

### Что делать, если я хочу переместить что-то еще, кроме курсора мыши, на что-то еще, кроме экрана?

В этом случае вам необходимо предоставить фабрике свои собственные `ISystemCalls` и `IMouseInfoAccessor`.

В `ISystemCalls` вам нужно реализовать `SetMousePosition(int x, int y)`, чтобы он вызывал необходимое устройство с новыми координатами.

В `IMouseInfoAccessor` вам необходимо реализовать свойство `MousePosition` для получения координат курсора с указанного устройства.

И это в основном все, остальное обрабатывается внутри CSNaturalMouseMotion.